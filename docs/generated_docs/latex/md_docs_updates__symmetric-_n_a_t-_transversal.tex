Notes\+:

\hyperlink{struct_friend}{Friend} requests need to be routed.

The current \hyperlink{struct_d_h_t}{D\+H\+T} should be capable of punching all N\+A\+Ts except symmetric ones.

\subparagraph*{}

Symmetric \hyperlink{struct_n_a_t}{N\+A\+T} hole punching\+:

If we are not connected to the friend and if the \hyperlink{struct_d_h_t}{D\+H\+T} is queried and ips returned for the friend are the same but the port is different, the friend is assumed to be behind a symmetric \hyperlink{struct_n_a_t}{N\+A\+T}.

Before attempting the procedure we first send a routed ping request to the friend. This request is to be routed through the nodes who returned the ip of the peer.

As soon as we receive one routed ping request from the other peer, we respond with a ping response.

Ping request/response packet\+: See\+: Crypto request packets in \mbox{[}\mbox{[}Crypto\mbox{]}\mbox{]}

Message\+: For the ping request\+: \mbox{[}char with a value of 254\mbox{]}\mbox{[}char with 0\mbox{]}\mbox{[}8 byte random number\mbox{]}

For the ping response\+: \mbox{[}char with a value of 254\mbox{]}\mbox{[}char with 1\mbox{]}\mbox{[}8 byte random number (The same that was sent in the request)\mbox{]}

As soon as we get a proper ping response from the other we run the different ports returned by the \hyperlink{struct_d_h_t}{D\+H\+T} through our port guessing algorithm.

\subparagraph*{}

Port guessing algorithm\+:

Right now it just tries all the ports directly beside the known ports.(A better one is needed)

\subparagraph*{}

We send \hyperlink{struct_d_h_t}{D\+H\+T} ping requests to all the guessed ports, only a couple at a time. 